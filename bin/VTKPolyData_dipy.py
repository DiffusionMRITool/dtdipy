#!/usr/bin/env python
"""
Description: Render a list of VTK data, track data, a nifti image, then view or save PNG or save WebGL.
The code uses dipy and fury.

Usage:
  VTKPolyData_dipy.py [--vtk <vtk_file>] [--vtk2 <vtk2_file>] [--image <nifti_file>] [--track <track_file>] [--size size] [--world_coords] [--frame] [--scalar_range r1,r2] [--png pngfile] [--zoom zoom] [--bgcolor color] [-v] [--no-normal] [--so opa]
  VTKPolyData_dipy.py (-h | --help)

Options:

  --vtk <vtk_file>         Input VTK PolyData (.vtk, .vtp, etc), multiple inputs (file1,file2,...). Use HueRange=(0.6667,0).
  --vtk2 <vtk_file>        Input VTK Polydata, multiple inputs. Use HueRange=(0,1). Specified for meshes from tensors colored by directions, generated by MeshFromTensors.
  --image <nifti_file>     Input nifti image file.
  --track <track_file>     Input track file (.trk, .tck). Multiple inputs.
  --scalar_range r1,r2     lowest and highest scalar values for the vtk coloring. It is used when scalar dimention is 1. If not set, use the range of the scalar values. [Default: -1,-1]
  --size size              Window size in pixels. [Default: 1200,900]
  --so opacity             Slice opacity. [Default: 0.6]
  --world_coords           Use world coordinates.
  --png png_file           Output png file.
  --zoom zoom              Camera zoom factor. [Default: 1.1]
  --bgcolor color          Back ground color. [Default: 0,0,0]
  --frame                  Wireframe visualization.
  --no-normal              Do not use vtkPolyDataNormals for polydata visualization.

  -h --help                Show this screen.
  -v --verbose             Verbose.


Author(s): Jian Cheng (jian.cheng.1983@gmail.com)
"""

import vtk, os
import numpy as np
from docopt import docopt

import utlVTK
import utlDMRITool as utl

import nibabel as nib
from fury import actor, window, ui
from dipy.io.image import load_nifti
from dipy.io.streamline import load_tractogram
from dipy.io.vtk import load_vtk_streamlines
from dipy.io.dpy import Dpy


def arg_values(value, typefunc, numberOfValues):
    '''set arguments based using comma. If numberOfValues<0, it supports arbitrary number of inputs.'''
    value = value.strip()
    if value[0]=='(' and value[-1]==')':
        value = value[1:-1]
    values = value.split(',')
    if numberOfValues > 0 and len(values) != numberOfValues:
        raise "aa"
    return list(map(typefunc, values))


def get_input_args(args):
    '''parse args'''
    _args = args
    _args['--vtk'] = args['--vtk'].split(',') if args['--vtk'] else args['--vtk']
    _args['--vtk2'] = args['--vtk2'].split(',') if args['--vtk2'] else args['--vtk2']
    _args['--track'] = args['--track'].split(',') if args['--track'] else args['--track']
    _args['--scalar_range'] = arg_values(args['--scalar_range'], float, 2)
    _args['--size'] = arg_values(args['--size'], int, 2)
    _args['--bgcolor'] = arg_values(args['--bgcolor'], float, 3)
    _args['--so'] = arg_values(args['--so'], float, 1)[0]
    _args['--zoom'] = arg_values(args['--zoom'], float, 1)[0]
    return _args


def scene_add_tract(scene, track_file, affine, _args):
    '''add a track file'''

    if _args['--image']:
        tg = load_tractogram(track_file, _args['--image'], bbox_valid_check=False)
        streamlines = tg.streamlines
    else:
        _, extension = os.path.splitext(track_file)
        if extension == '.trk':
            tg = load_tractogram(track_file, 'same', bbox_valid_check=False)
            streamlines = tg.streamlines
        elif extension == '.tck':
            tractogram_obj = nib.streamlines.load(track_file).tractogram
            streamlines = tractogram_obj.streamlines
        elif extension in ['.vtk', '.fib']:
            streamlines = load_vtk_streamlines(track_file)
        elif extension in ['.dpy']:
            dpy_obj = Dpy(track_file, mode='r')
            streamlines = list(dpy_obj.read_tracks())
            dpy_obj.close()

    if not _args['--world_coords']:
        from dipy.tracking.streamline import transform_streamlines
        streamlines = transform_streamlines(streamlines, np.linalg.inv(affine))

    stream_actor = actor.line(streamlines)

    scene.add(stream_actor)


def scene_add_vtk(scene, vtk_file, _args, is_vtk2):
    '''add a vtk file'''

    polyData = utlVTK.readPolydata(vtk_file)

    if _args['--frame']:
        frame_mapper = vtk.vtkDataSetMapper()
        frame_mapper.SetInputData(polyData)
        frame_actor = vtk.vtkLODActor()
        frame_actor.SetMapper(frame_mapper)
        prop = frame_actor.GetProperty()
        prop.SetRepresentationToWireframe()
        prop.SetColor(0.0, 0.0, 1.0)
        scene.AddActor(frame_actor)

    surface_mapper = vtk.vtkDataSetMapper()

    if not _args['--no-normal'] and polyData.GetPointData().GetNormals() is None:
        polyDataNormals = vtk.vtkPolyDataNormals()
        try:
            polyDataNormals.SetInputData(polyData)
        except:
            polyDataNormals.SetInput(polyData)
        # polyDataNormals.SetFeatureAngle(90.0)
        surface_mapper.SetInputConnection(
            polyDataNormals.GetOutputPort())
    else:
        try:
            surface_mapper.SetInputData(polyData)
        except:
            surface_mapper.SetInput(polyData)

    if polyData.GetPointData().GetScalars() and polyData.GetPointData().GetScalars().GetNumberOfComponents()==1:
        lut = vtk.vtkLookupTable()
        if _args['--scalar_range'][0] == -1 or _args['--scalar_range'][1] == -1:
            valueRange = polyData.GetScalarRange()
        vr0 = _args['--scalar_range'][0] if _args['--scalar_range'][0] != -1 else valueRange[0]
        vr1 = _args['--scalar_range'][1] if _args['--scalar_range'][1] != -1 else valueRange[1]
        valueRange = (vr0, vr1)
        lut.SetTableRange(valueRange[0], valueRange[1])
        if is_vtk2:
            #  for tensors colored by directions
            lut.SetHueRange(0.0,1.0)
        else:
            lut.SetHueRange(0.6667, 0)
        #  lut.SetHueRange(args.hue_range[0], args.hue_range[1])
        lut.SetRampToLinear()
        lut.Build()

        surface_mapper.SetLookupTable(lut)
        surface_mapper.SetScalarRange(valueRange[0], valueRange[1])

    surface_actor = vtk.vtkLODActor()
    surface_actor.SetMapper(surface_mapper)
    prop = surface_actor.GetProperty()
    prop.SetRepresentationToSurface()

    scene.add(surface_actor)


def scene_add_image(scene, image_file, _args):
    '''add an image'''

    data, affine = load_nifti(image_file)
    shape = data.shape
    if _args['--verbose']:
        print('shape=', shape)
        print('affine=', affine)

    if not _args['--world_coords']:
        image_actor_z = actor.slicer(data, affine=np.eye(4))
    else:
        image_actor_z = actor.slicer(data, affine)


    image_actor_z.opacity(_args['--so'])


    image_actor_x = image_actor_z.copy()
    x_midpoint = int(np.round(shape[0] / 2))
    image_actor_x.display_extent(x_midpoint,
                                x_midpoint, 0,
                                shape[1] - 1,
                                0,
                                shape[2] - 1)

    image_actor_y = image_actor_z.copy()
    y_midpoint = int(np.round(shape[1] / 2))
    image_actor_y.display_extent(0,
                                shape[0] - 1,
                                y_midpoint,
                                y_midpoint,
                                0,
                                shape[2] - 1)

    scene.add(image_actor_z)
    scene.add(image_actor_x)
    scene.add(image_actor_y)

    return image_actor_x, image_actor_y, image_actor_z, affine, shape


def scene_add_ui(scene, _args, image_actor_x, image_actor_y, image_actor_z, affine, shape):
    '''add ui for image slice'''

    line_slider_x = ui.LineSlider2D(min_value=0,
                                    max_value=shape[0] - 1 if shape[0]>1 else 1,
                                    initial_value=shape[0] / 2,
                                    text_template="{value:.0f}",
                                    length=140)

    line_slider_y = ui.LineSlider2D(min_value=0,
                                    max_value=shape[1] - 1 if shape[1]>1 else 1,
                                    initial_value=shape[1] / 2,
                                    text_template="{value:.0f}",
                                    length=140)

    line_slider_z = ui.LineSlider2D(min_value=0,
                                    max_value=shape[2] - 1 if shape[2]>1 else 1,
                                    initial_value=shape[2] / 2,
                                    text_template="{value:.0f}",
                                    length=140)

    opacity_slider = ui.LineSlider2D(min_value=0.0,
                                    max_value=1.0,
                                    initial_value=_args['--so'],
                                    length=140)



    def change_slice_z(slider):
        z = int(np.round(slider.value))
        image_actor_z.display_extent(0, shape[0] - 1, 0, shape[1] - 1, z, z)


    def change_slice_x(slider):
        x = int(np.round(slider.value))
        image_actor_x.display_extent(x, x, 0, shape[1] - 1, 0, shape[2] - 1)


    def change_slice_y(slider):
        y = int(np.round(slider.value))
        image_actor_y.display_extent(0, shape[0] - 1, y, y, 0, shape[2] - 1)


    def change_opacity(slider):
        _args['--so'] = slider.value
        image_actor_z.opacity(_args['--so'])
        image_actor_x.opacity(_args['--so'])
        image_actor_y.opacity(_args['--so'])


    line_slider_z.on_change = change_slice_z
    line_slider_x.on_change = change_slice_x
    line_slider_y.on_change = change_slice_y
    opacity_slider.on_change = change_opacity


    def build_label(text):
        label = ui.TextBlock2D()
        label.message = text
        label.font_size = 18
        label.font_family = 'Arial'
        label.justification = 'left'
        label.bold = False
        label.italic = False
        label.shadow = False
        label.background_color = (0, 0, 0)
        label.color = (1, 1, 1)

        return label


    line_slider_label_z = build_label(text="Z Slice")
    line_slider_label_x = build_label(text="X Slice")
    line_slider_label_y = build_label(text="Y Slice")
    opacity_slider_label = build_label(text="Opacity")


    bgc = _args['--bgcolor']
    panel = ui.Panel2D(size=(300, 200),
                    color=(1-bgc[0], 1-bgc[1], 1-bgc[2]),
                    opacity=0.1,
                    align="right")
    panel.center = (_args['--size'][0]-200, 120)

    panel.add_element(line_slider_label_x, (0.1, 0.75))
    panel.add_element(line_slider_x, (0.38, 0.75))
    panel.add_element(line_slider_label_y, (0.1, 0.55))
    panel.add_element(line_slider_y, (0.38, 0.55))
    panel.add_element(line_slider_label_z, (0.1, 0.35))
    panel.add_element(line_slider_z, (0.38, 0.35))
    panel.add_element(opacity_slider_label, (0.1, 0.15))
    panel.add_element(opacity_slider, (0.38, 0.15))

    scene.add(panel)

    return panel



def main():

    args = docopt(utl.app_doc(__doc__), version='1.0')

    if (args['--verbose']):
        print(args)

    _args = get_input_args(args)

    if (args['--verbose']):
        print('_args=',_args)

    affine=np.eye(4)

    scene = window.Scene()


    #  add vtk files
    if _args['--vtk']:
        for tf in _args['--vtk']:
            scene_add_vtk(scene, os.path.expanduser(tf), _args, False)


    #  add vtk2 files for tensors
    if _args['--vtk2']:
        for tf in _args['--vtk2']:
            scene_add_vtk(scene, os.path.expanduser(tf), _args, True)


    #  add an image file
    if _args['--image']:
        image_actor_x, image_actor_y, image_actor_z, affine, shape = scene_add_image(scene, _args['--image'], _args)


    #  add track files
    if _args['--track']:
        for tf in _args['--track']:
            scene_add_tract(scene, os.path.expanduser(tf), affine, _args)

    show_m = window.ShowManager(scene, size=(_args['--size']))
    show_m.initialize()

    # add ui for image slice
    if _args['--image']:
        panel = scene_add_ui(scene, _args, image_actor_x, image_actor_y, image_actor_z, affine, shape)



    global size
    size = scene.GetSize()

    def win_callback(obj, _event):
        global size
        if size != obj.GetSize():
            size_old = size
            size = obj.GetSize()
            size_change = [size[0] - size_old[0], 0]
            panel.re_align(size_change)

    scene.SetBackground(_args['--bgcolor'])

    show_m.initialize()

    scene.zoom(_args['--zoom'])
    scene.reset_clipping_range()

    if not _args['--png']:

        show_m.add_window_callback(win_callback)
        show_m.render()
        show_m.start()

    else:

        window.record(scene, out_path=_args['--png'], size=(_args['--size']),
                    reset_camera=False)





if __name__ == '__main__':
    main()

